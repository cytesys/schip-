#include <stdexcept>
#include <fstream>
#include <sys/types.h>
#include <sys/stat.h>

#include "memory.hpp"
#include "common.hpp"

// The address space 0x200..0xe9f is allocated to the user
// program. That leaves us with 0xca0 bytes.
constexpr int BUF_SIZE = 0xca0;

// 4x5 pixel hexadecimal character font patterns
constexpr std::array<uint8_t, 80> hexfont = {
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};

// 8x10 pixel font patterns(only 10)
constexpr std::array<uint8_t, 100> bigfont = {
    0x3c, 0x7e, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7e, 0x3c, // 0
    0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, // 1
    0x3e, 0x7f, 0xc3, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xff, 0xff, // 2
    0x3c, 0x7e, 0xc3, 0x03, 0x0e, 0x0e, 0x03, 0xc3, 0x7e, 0x3c, // 3
    0x06, 0x0e, 0x1e, 0x36, 0x66, 0xc6, 0xff, 0xff, 0x06, 0x06, // 4
    0xff, 0xff, 0xc0, 0xc0, 0xfc, 0xfe, 0x03, 0xc3, 0x7e, 0x3c, // 5
    0x3e, 0x7c, 0xc0, 0xc0, 0xfc, 0xfe, 0xc3, 0xc3, 0x7e, 0x3c, // 6
    0xff, 0xff, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x60, 0x60, // 7
    0x3c, 0x7e, 0xc3, 0xc3, 0x7e, 0x7e, 0xc3, 0xc3, 0x7e, 0x3c, // 8
    0x3c, 0x7e, 0xc3, 0xc3, 0x7f, 0x3f, 0x03, 0x03, 0x3e, 0x7c  // 9
};

MMU::MMU() {
    int i;
    int index = 0;

    // Copy the hexfont into memory
    for (i = 0; i < hexfont.size(); i++) {
        this->m_mem.at(index++) = hexfont.at(i);
    }

    // Copy the big font into memory
    for (i = 0; i < bigfont.size(); i++) {
        this->m_mem.at(index++) = bigfont.at(i);
    }
}

uint8_t MMU::read(uint16_t address) {
    if (address >= 0x0 && address < 0x1000) {
        return this->m_mem.at(address);
    }

    throw std::out_of_range("Cannot read from address 0x" + n2hexstr(address));
}

void MMU::write(uint16_t address, uint8_t byte) {
    if (address >= 0x200 && address < 0x1000) {
        this->m_mem.at(address) = byte;
        return;
    }

    throw std::out_of_range("Cannot write to address 0x" + n2hexstr(address));
}

void MMU::load_program(const char* filename) {
    struct stat info;
    int status = stat(filename, &info);

    if (status == -1) {
        throw std::runtime_error("File not found!");
    }
    
    int i, index = 0x200;
    size_t read;
    char buffer[BUF_SIZE] = {};

    std::ifstream file(
        filename,
        std::ios_base::in | std::ios::binary
    );

    if (file.peek() != EOF) {
        file.read(buffer, BUF_SIZE);
        read = file.gcount();

        // Copy everything into m_mem.
        for (i = 0; i < read; i++) {
            this->m_mem.at(index++) = buffer[i];
        }

        if ((read == BUF_SIZE) && (file.peek() != EOF)) {
            // There's more data??
            file.close();
            throw std::length_error(
                "File is too big! Is the file really a chip8 program?"
            );
        }

    } else {
        file.close();
        throw std::runtime_error("Cannot read from file");
    }

    file.close();
}
