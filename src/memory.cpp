#include <schip/memory.h>

// 4x5 pixel hexadecimal character font patterns
constexpr std::array<uint8_t, 80> HEX_FONT = {
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};

// 8x10 pixel font patterns(only 10)
constexpr std::array<uint8_t, 100> BIG_HEX_FONT = {
    0x3c, 0x7e, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7e, 0x3c, // 0
    0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, // 1
    0x3e, 0x7f, 0xc3, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xff, 0xff, // 2
    0x3c, 0x7e, 0xc3, 0x03, 0x0e, 0x0e, 0x03, 0xc3, 0x7e, 0x3c, // 3
    0x06, 0x0e, 0x1e, 0x36, 0x66, 0xc6, 0xff, 0xff, 0x06, 0x06, // 4
    0xff, 0xff, 0xc0, 0xc0, 0xfc, 0xfe, 0x03, 0xc3, 0x7e, 0x3c, // 5
    0x3e, 0x7c, 0xc0, 0xc0, 0xfc, 0xfe, 0xc3, 0xc3, 0x7e, 0x3c, // 6
    0xff, 0xff, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x60, 0x60, // 7
    0x3c, 0x7e, 0xc3, 0xc3, 0x7e, 0x7e, 0xc3, 0xc3, 0x7e, 0x3c, // 8
    0x3c, 0x7e, 0xc3, 0xc3, 0x7f, 0x3f, 0x03, 0x03, 0x3e, 0x7c  // 9
};

Bus::Bus() : m_data({}) {}

Bus::~Bus() {}

uint8_t Bus::read(uint16_t addr) const {
    if (addr >= MEM_ADDR_END) {
        fprintf(stderr, "Tried to read from address [0x%.4x]\n", addr);
        throw std::out_of_range("Bus read: Address is out of range");
    }
    
    if (addr < 0x50) {
        return HEX_FONT.at(addr);
    } else if (addr < 0xb4) {
        return BIG_HEX_FONT.at(addr - 0x50);
    } else if (addr < MEM_ADDR_BEG) {
        // Empty/unused space
        fprintf(stderr, "Warning: Reading garbage from [0x%.4x]\n", addr);
        return 0xff;
    }

    return this->m_data.at(addr - MEM_ADDR_BEG);
}

void Bus::write(uint16_t addr, uint8_t byte) {
    if (addr < MEM_ADDR_BEG || addr >= MEM_ADDR_END) {
        fprintf(stderr, "Tried to write to address [0x%.4x]\n", addr);
        throw std::out_of_range("Bus write: Address is out of range");
    }

    this->m_data.at(addr - MEM_ADDR_BEG) = byte;
}

void Bus::load_program(const char* const filename) {
    struct stat info;
    int status = stat(filename, &info);

    if (status == -1) {
        throw std::runtime_error("File not found!");
    }
    
    const size_t bufsize = MEM_ADDR_END - MEM_ADDR_BEG;
    char buffer[bufsize] = {};

    std::ifstream file(
        filename,
        std::ios_base::in | std::ios::binary
    );

    if (file.peek() != EOF) {
        file.read(buffer, bufsize);
        size_t read = file.gcount();

        if (read == 0) {
            throw std::runtime_error("Could not read from file; read 0 bytes");
        }

        // Copy everything into m_mem.
        for (int i = 0; i < read; i++) {
            this->m_data.at(i) = buffer[i];
        }

        if (file.peek() != EOF) {
            // There's more data??
            file.close();
            throw std::length_error(
                "The file is too big! Is this really a chip8 program?"
            );
        }

    } else {
        file.close();
        throw std::runtime_error("Cannot read from file. Is it empty?");
    }

    file.close();
}
